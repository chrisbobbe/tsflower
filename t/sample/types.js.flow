/* @flow
 * @generated by TsFlower
 */
/**
 * Tests of simple and miscellaneous types.
 *
 * Some kinds of types have their own test files.  For example:
 *   function.d.ts
 *   members.d.ts
 *   generics.d.ts
 */
declare export var latticeTypes: {
    unk: mixed,
    any_: any,
    nevr: empty,
    ...
};

declare var keywordTypes: {
    undef: void,
    void_: void,
    bool: boolean,
    num: number,
    str: string,
    sym: symbol,
    obj: {...},
    ...
};

declare var literalTypes: {
    n: null,
    t: true,
    f: false,
    num: {
        nat: 3,
        neg: -1,
        float: 1.2,
        floatNeg: -2.3,
        expPIP: 100,
        expPFP: 1200,
        expPIN: 0.01,
        expPFN: 0.0012,
        expNIP: -100,
        expNFP: -1200,
        expNIN: -0.01,
        expNFN: -0.0012,
        ...
    },
    str: "x",
    ...
};

declare var typeOperations: {
    parens: number,
    query: {
        l: typeof literalTypes,
        ln: typeof literalTypes.n,
        ...
    },
    keys: $Keys<typeof literalTypes>,
    union: "a" | 3,
    intersection: { a: "a" | "b", ... } & { a: "b" | "c", ... },
    indexedAccess: $ElementType<{ a: string, ... }, "a">,
    indexedKeys: {
        typeof_: $Values<typeof literalTypes>,
        typeofMismatch1: $ElementType<typeof literalTypes, $Keys<typeof literalTypes.n>>,
        typeofMismatch2: $ElementType<typeof literalTypes, $Keys<typeof keywordTypes>>,
        tparam: <T>(o: T) => $Values<T>,
        tparam2: <T, S>(o: T, p: S) => $Values<T>,
        tparamMismatch: <T, S>(o: T, p: S) => $ElementType<T, $Keys<S>>,
        obj1: $Values<{ a: string, ... }>,
        obj2: $Values<{ a(): string, ... }>,
        objMismatch1: $ElementType<{ a: string, ... }, $Keys<{ b: string, ... }>>,
        objMismatch2: $ElementType<{ a: string, ... }, $Keys<{ a(): string, ... }>>,
        ...
    },
    array: boolean[],
    tuple: {
        zero: [],
        one: [string],
        two: [string, number],
        eight: [void, void, null, boolean, true, false, number, string],
        named: [string],
        named2: [string, number],
        ...
    },
    ...
};
