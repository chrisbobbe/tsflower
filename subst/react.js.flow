/**
 * Flow type definitions corresponding to the TS definitions in `@types/react`.
 *
 * TsFlower will rewrite some TS references to React types so that their
 * Flow versions refer instead to these types.
 *
 * @flow
 */

import * as React from 'react';

// In @types/react:
//   type PropsWithChildren<P> = P & { children?: ReactNode | undefined };
export type PropsWithChildren<+P> = { ...P, children?: React$Node | void, ... };

// In @types/react:
//   /** Ensures that the props do not include ref at all */
//   type PropsWithoutRef<P> = …
// The definition is complicated for reasons that seem TS-specific.
// Make it easy with Flow's `$Rest`.
export type PropsWithoutRef<P> = $Rest<P, {| ref: mixed |}>;

// In @types/react:
//   interface MutableRefObject<T> { current: T; }
export type MutableRefObject<T> = { current: T, ... };

// See comment on `Ref` below.
export type RefObject<T> = { +current: T | null, ... };

// Definition in @types/react/index.d.ts:
//   interface RefObject<T> {
//     readonly current: T | null;
//   }
//   // Bivariance hack for consistent unsoundness with RefObject
//   type RefCallback<T> = { bivarianceHack(instance: T | null): void }["bivarianceHack"];
//   type Ref<T> = RefCallback<T> | RefObject<T> | null;
//
// There's no definition in flowlib's react.js that corresponds; the types
// of `useImperativeHandle` and `forwardRef` spell it out.  There's
// `React.Ref`, but it's the type of the `ref` pseudoprop; its type
// parameter is the ElementType of the element, and it passes that to
// `React$ElementRef` to work out what type the ref should hold.
//
// So, just give a definition of our own.
export type RefCallback<T> = (T | null) => mixed;
// NB mixed return, not void; see e.g. flowlib's React$Ref
export type Ref<T> = RefCallback<T> | RefObject<T> | null;

// Definition in @types/react/index.d.ts:
//   type Key = string | number;
//   interface Attributes {
//     key?: Key | null | undefined;
//   }
//   interface RefAttributes<T> extends Attributes {
//     ref?: Ref<T> | undefined;
//   }
export type RefAttributes<T> = {
  key?: string | number | void | null,
  ref?: void | Ref<T>,
  ...
};

// The `@types/react` definition of ForwardRefExoticComponent has
// various hair on it, but ultimately its job is to model the return
// type of React.forwardRef.  In flowlib, that returns a certain
// React$AbstractComponent.  The second ("Instance") type parameter
// seems hard to recover, so just approximate it as `mixed`… and that's
// what React$ComponentType does.
export type ForwardRefExoticComponent<-P> = React.ComponentType<P>;

// Similarly MemoExoticComponent models the return type of React.memo.
// Here the type argument is actually the component type (the type of
// the function's first argument), not the props.  In flowlib, the
// argument and return types are the same; so it's the identity.
export type MemoExoticComponent<+T> = T;

// And NamedExoticComponent is the base interface of ForwardRefExoticComponent.
export type NamedExoticComponent<-P> = React.ComponentType<P>;

// @types/react/index.d.ts (whitespace and comments elided):
//   interface ProviderProps<T> {
//       value: T;
//       children?: ReactNode | undefined;
//   }
//   interface ConsumerProps<T> {
//       children: (value: T) => ReactNode;
//   }
//   // …
//   type Provider<T> = ProviderExoticComponent<ProviderProps<T>>;
//   type Consumer<T> = ExoticComponent<ConsumerProps<T>>;
//   interface Context<T> {
//       Provider: Provider<T>;
//       Consumer: Consumer<T>;
//       displayName?: string | undefined;
//   }
// and then createContext on a T returns a Context<T>.
//
// In flowlib, most of those pieces don't get names.  But there is a
// React.Context (aka React$Context) with the same meaning.
export type Provider<T> = $ElementType<React$Context<T>, 'Provider'>;
export type Consumer<T> = $ElementType<React$Context<T>, 'Consumer'>;
export type ProviderProps<T> = React$ElementConfig<Provider<T>>;
export type ConsumerProps<T> = React$ElementConfig<Consumer<T>>;

//   // @types/react/index.d.ts
//   declare global {
//     namespace JSX {
//         interface Element extends React.ReactElement<any, any> { }
// Currently we handle React.ReactElement with a macro;
// do here what that macro would give on `any, any`.
export type JSX$Element = React$Element<any>;
