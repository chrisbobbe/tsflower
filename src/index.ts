/**
 * Usage: node . path/to/some/file.d.ts
 *
 * Prints result to stdout.
 *
 * Example:
 *   $ node . integration/node_modules/react-native-gesture-handler/lib/typescript/index.d.ts
 */
import ts from "typescript";
import * as recast from "recast";
import { builders as b, namedTypes as n } from "ast-types";
import K from "ast-types/gen/kinds";
import process from "process";

const headerComment = ` ${"@"}flow
 * ${"@"}generated by TsFlow
 `;

main();

function main() {
  process.stdout.write(convertFileToString(process.argv[2]));
}

function convertFileToString(file: string): string {
  const program = ts.createProgram({
    rootNames: [file],
    options: {},
  });
  program.getTypeChecker(); // causes the binder to run, and set parent pointers
  const sourceFile = program.getSourceFile(file);
  if (!sourceFile) throw 0;
  const convertedFile = convertSourceFile(sourceFile);
  return recast.print(convertedFile).code + "\n";
}

function convertSourceFile(node: ts.SourceFile): n.File {
  return b.file(
    b.program.from({
      comments: [b.commentBlock(headerComment)],
      body: node.statements.map(convertStatement),
    }),
    node.fileName
  );
}

function convertStatement(node: ts.Statement): K.StatementKind {
  switch (node.kind) {
    default:
      return unimplementedStatement(node);
  }
}

function unimplementedStatement(node: ts.Statement): K.StatementKind {
  const sourceFile = node.getSourceFile();
  const text = sourceFile.text.slice(node.pos, node.end);
  const msg = ` tsflow-unimplemented: ${ts.SyntaxKind[node.kind]} `;
  return b.emptyStatement.from({
    comments: [
      b.commentBlock(msg, true, false),
      b.commentBlock(` ${text} `, false, true),
    ],
  });
}

function errorStatement(description: string): K.StatementKind {
  return b.emptyStatement.from({
    comments: [b.commentBlock(` tsflow-error: ${description} `)],
  });
}
