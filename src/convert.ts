import ts from 'typescript';
import { builders as b, namedTypes as n } from 'ast-types';
import K from 'ast-types/gen/kinds';
import { forEach, map, some } from './util';
import { Mapper } from './mapper';
import {
  getModuleSpecifier,
  hasModifier,
  isEntityNameOrEntityNameExpression,
} from './tsutil';
import { assertUnreachable, ensureUnreachable } from './generics';
import { escapeNamesAsIdentifierWithPrefix } from './names';
import { formatSyntaxKind } from './tsdebug';
import { SubstituteType } from './rewrite/core';

export type ErrorDescription = {
  kind: 'unimplemented' | 'error';
  description: string;
};

export const mkError = (description: string): ErrorDescription => ({
  kind: 'error',
  description,
});

export const mkUnimplemented = (description: string): ErrorDescription => ({
  kind: 'unimplemented',
  description,
});

export type ErrorOr<T> = { kind: 'success'; result: T } | ErrorDescription;

export const mkSuccess = <T>(result: T): ErrorOr<T> => ({
  kind: 'success',
  result,
});

export interface Converter {
  convertType(node: ts.TypeNode): K.FlowTypeKind;
  convertEntityNameAsType(
    node: ts.EntityNameOrEntityNameExpression,
  ): K.IdentifierKind | K.QualifiedTypeIdentifierKind;
  errorType(node: ts.TypeNode, description: string): K.FlowTypeKind;
  unimplementedType(node: ts.TypeNode, description: string): K.FlowTypeKind;
  crudeError(node: ts.Node, description: string): never;
}

const headerComment = ` ${'@'}flow
 * ${'@'}generated by TsFlower
 `;

export function convertSourceFile(
  sourceFile: ts.SourceFile,
  mapper: Mapper,
  program: ts.Program,
): n.File {
  const checker = program.getTypeChecker();

  // Elements are local names.
  const importTypeImports: Set<string> = new Set();

  // Elements are names from SubstituteType rewrites.
  const substituteTypes: Set<string> = new Set();

  const preambleStatements: K.StatementKind[] = [];

  const converter: Converter = {
    convertType,
    convertEntityNameAsType,
    errorType,
    unimplementedType,
    crudeError,
  };

  const convertedStatements = sourceFile.statements.map(convertStatement);

  const body = preambleStatements.length
    ? [...preambleStatements, ...convertedStatements]
    : convertedStatements;

  return b.file(
    b.program.from({
      comments: [b.commentBlock(headerComment)],
      body,
    }),
    sourceFile.fileName,
  );

  function convertStatement(node: ts.Statement): K.StatementKind {
    try {
      const inner = convertStatementExceptExport(node);

      if (hasModifier(node, ts.SyntaxKind.ExportKeyword)) {
        return modifyStatementAsExport(inner, node);
      }

      return inner;
    } catch (err) {
      console.error(err);
      return errorStatement(node, `internal error: ${(err as Error).message}`);
    }
  }

  function modifyStatementAsExport(
    inner: K.StatementKind,
    node: ts.Statement,
  ): K.StatementKind {
    if (n.DeclareFunction.check(inner) || n.DeclareClass.check(inner)) {
      // TODO are there more cases that should go this way?
      return b.declareExportDeclaration(
        hasModifier(node, ts.SyntaxKind.DefaultKeyword),
        inner,
      );
    } else if (n.DeclareInterface.check(inner)) {
      // Awkwardly convert a DeclareInterface to an InterfaceDeclaration.
      // This causes recast to correctly emit `export interface`
      // instead of `export declare interface`, which Flow rejects.
      return b.exportNamedDeclaration(
        b.interfaceDeclaration.from({
          id: inner.id,
          typeParameters: inner.typeParameters,
          extends: inner.extends,
          body: inner.body,
        }),
      );
    } else if (n.Declaration.check(inner)) {
      // The generic case.
      return b.exportNamedDeclaration(inner as K.DeclarationKind);
    } else if (n.EmptyStatement.check(inner)) {
      // Presumably an error or unimplemented.  Nothing further to log.
      return inner;
    } else {
      return warningStatement(
        inner,
        node,
        `statement has "export", but conversion not a declaration`,
      );
    }
  }

  function convertStatementExceptExport(node: ts.Statement): K.StatementKind {
    switch (node.kind) {
      case ts.SyntaxKind.ImportDeclaration:
        return convertImportDeclaration(node as ts.ImportDeclaration);

      case ts.SyntaxKind.ExportDeclaration:
        return convertExportDeclaration(node as ts.ExportDeclaration);

      case ts.SyntaxKind.ExportAssignment:
        return convertExportAssignment(node as ts.ExportAssignment);

      case ts.SyntaxKind.VariableStatement:
        return convertVariableStatement(node as ts.VariableStatement);

      case ts.SyntaxKind.TypeAliasDeclaration:
        return convertTypeAliasDeclaration(node as ts.TypeAliasDeclaration);

      case ts.SyntaxKind.FunctionDeclaration:
        return convertFunctionDeclaration(node as ts.FunctionDeclaration);

      case ts.SyntaxKind.ClassDeclaration:
      case ts.SyntaxKind.InterfaceDeclaration:
        return convertClassLikeDeclaration(
          node as ts.ClassDeclaration | ts.InterfaceDeclaration,
        );

      case ts.SyntaxKind.EmptyStatement:
        return b.emptyStatement();

      case ts.SyntaxKind.Block: // TODO(runtime)
        // Blocks can't contain exports, nor any declarations visible
        // outside the block.  So they don't matter for type definitions.
        return b.emptyStatement();

      case ts.SyntaxKind.EnumDeclaration:
      case ts.SyntaxKind.ModuleDeclaration:
      case ts.SyntaxKind.NamespaceExportDeclaration:
      case ts.SyntaxKind.ImportEqualsDeclaration:
        // These statements might actually appear in .d.ts files.
        return unimplementedStatement(node, formatSyntaxKind(node.kind));

      case ts.SyntaxKind.ExpressionStatement:
      case ts.SyntaxKind.IfStatement:
      case ts.SyntaxKind.DoStatement:
      case ts.SyntaxKind.WhileStatement:
      case ts.SyntaxKind.ForStatement:
      case ts.SyntaxKind.ForInStatement:
      case ts.SyntaxKind.ForOfStatement:
      case ts.SyntaxKind.ContinueStatement:
      case ts.SyntaxKind.BreakStatement:
      case ts.SyntaxKind.ReturnStatement:
      case ts.SyntaxKind.WithStatement:
      case ts.SyntaxKind.SwitchStatement:
      case ts.SyntaxKind.LabeledStatement:
      case ts.SyntaxKind.ThrowStatement:
      case ts.SyntaxKind.TryStatement:
      case ts.SyntaxKind.DebuggerStatement:
      case ts.SyntaxKind.CaseBlock:
        // TODO(runtime): These shouldn't appear in .d.ts files.  So they
        // shouldn't come up unless we try to handle normal source files.
        return unimplementedStatement(node, formatSyntaxKind(node.kind));

      case ts.SyntaxKind.VariableDeclaration:
      case ts.SyntaxKind.VariableDeclarationList:
      case ts.SyntaxKind.ModuleBlock:
      case ts.SyntaxKind.ImportClause:
      case ts.SyntaxKind.NamespaceImport:
      case ts.SyntaxKind.NamedImports:
      case ts.SyntaxKind.ImportSpecifier:
      case ts.SyntaxKind.NamedExports:
      case ts.SyntaxKind.NamespaceExport:
      case ts.SyntaxKind.ExportSpecifier:
        // Not actually statements -- pieces of statements.  We'll handle
        // these below, as part of handling the statements they appear in.
        return errorStatement(
          node,
          `unexpected statement kind: ${formatSyntaxKind(node.kind)}`,
        );

      case ts.SyntaxKind.MissingDeclaration:
      // These arise only when the input has a syntax error.
      // fallthrough

      default:
        return errorStatement(
          node,
          `unexpected statement kind: ${formatSyntaxKind(node.kind)}`,
        );
    }
  }

  function convertImportDeclaration(
    node: ts.ImportDeclaration,
  ): K.StatementKind {
    const { importClause } = node;
    if (!importClause) {
      return unimplementedStatement(
        node,
        'ImportDeclaration with no import clause',
      );
    }

    if (importClause.modifiers) {
      return unimplementedStatement(node, `ImportDeclaration with modifiers`);
    }

    const specifiers: (
      | n.ImportSpecifier
      | n.ImportNamespaceSpecifier
      | n.ImportDefaultSpecifier
    )[] = [];

    if (importClause.name) {
      specifiers.push(
        b.importDefaultSpecifier(convertIdentifier(importClause.name)),
      );
    }

    const { namedBindings } = importClause;
    if (namedBindings) {
      if (ts.isNamedImports(namedBindings)) {
        for (const binding of namedBindings.elements) {
          const { name } = binding;
          const propertyName = binding.propertyName ?? name;
          const localSymbol = checker.getSymbolAtLocation(name);
          const importedSymbol =
            localSymbol && checker.getImmediateAliasedSymbol(localSymbol);

          const mapped = importedSymbol && mapper.getSymbol(importedSymbol);
          if (mapped && mapped.kind === 'RenameType') {
            const mappedLocal = mapper.getSymbol(localSymbol);
            if (!mappedLocal || mappedLocal.kind !== 'RenameType') {
              // TODO(error): localize this to the one ts.ImportSpecifier
              return errorStatement(
                node,
                `internal error: renamed the imported type \`${propertyName.text}\`, ` +
                  `but not its local binding`,
              );
            }

            if (importClause.isTypeOnly) {
              // It's an `import type`.  Use the type's name, but don't say
              // `type` (the redundancy is invalid in both Flow and TS.)
              addImportSpecifier('value', mapped.name, mappedLocal.name);
            } else {
              // Not an `import type`.  Import the type with `type`…
              addImportSpecifier('type', mapped.name, mappedLocal.name);
              // … and then the value, unless this was `import { type Foo }`.
              if (!binding.isTypeOnly) {
                addImportSpecifier('value', propertyName.text, name.text);
              }
            }
            continue;
          }

          const isTypeOnly =
            binding.isTypeOnly ||
            // If the symbol is declared only as a type, not a value, then in
            // Flow we need to say "type" on the import.  (It might have both:
            // for example, both an interface and class declaration, like
            // React.Component does.)
            (importedSymbol &&
              !(importedSymbol.flags & ts.SymbolFlags.Value) &&
              // But if it's already an `import type`, avoid redundancy
              // (which would be a syntax error.)
              !importClause.isTypeOnly);

          addImportSpecifier(
            isTypeOnly ? 'type' : 'value',
            propertyName.text,
            name.text,
          );
        }
      } else {
        specifiers.push(
          b.importNamespaceSpecifier(convertIdentifier(namedBindings.name)),
        );
      }
    }

    const source = b.stringLiteral(getModuleSpecifier(node));

    const importKind =
      importClause.isTypeOnly &&
      // TS accepts `import type * as …`, but Flow doesn't.
      !(namedBindings && ts.isNamespaceImport(namedBindings))
        ? 'type'
        : 'value';

    return b.importDeclaration(specifiers, source, importKind);

    function addImportSpecifier(
      importKind: 'value' | 'type' | 'typeof',
      importedText: string,
      localText: string,
    ): void {
      const imported = b.identifier(importedText);
      const local = b.identifier(localText);
      specifiers.push(buildImportSpecifier(imported, local, importKind));
    }

    // TODO(ast-types): b.importSpecifier should take importKind, like this
    function buildImportSpecifier(
      imported: K.IdentifierKind,
      local?: K.IdentifierKind | null | undefined,
      importKind?: 'value' | 'type' | 'typeof' | undefined,
    ): n.ImportSpecifier {
      return b.importSpecifier.from({ imported, local, importKind });
    }
  }

  function convertExportDeclaration(
    node: ts.ExportDeclaration,
  ): K.StatementKind {
    const { isTypeOnly, exportClause, moduleSpecifier, assertClause } = node;

    if (assertClause) {
      return unimplementedStatement(node, "`export … from 'foo' assert { … }`");
    }

    const source = !moduleSpecifier
      ? null
      : // Quoth ExportDeclaration jsdoc:
        //   > If this is not a StringLiteral it will be a grammar error.
        b.stringLiteral((moduleSpecifier as ts.StringLiteral).text);

    if (!exportClause) {
      if (!source) {
        return errorStatement(node, 'expected `export *` to have `from`');
      }
      return b.exportAllDeclaration(source, null);
    } else if (ts.isNamespaceExport(exportClause)) {
      return b.exportNamedDeclaration(
        null,
        // @ts-expect-error TODO get ast-types and recast to handle this
        [b.exportNamespaceSpecifier(convertIdentifier(exportClause.name))],
        source,
      );
    } else if (ts.isNamedExports(exportClause)) {
      const specifiers = [];
      for (const spec of exportClause.elements) {
        const { isTypeOnly: specIsTypeOnly, propertyName, name } = spec;
        specifiers.push(
          b.exportSpecifier.from({
            local: convertIdentifier(propertyName ?? name),
            exported: convertIdentifier(name),
            // @ts-expect-error TODO(wrong) get ast-types and recast to handle this
            exportKind: specIsTypeOnly ? 'type' : 'value',
          }),
        );
      }
      return b.exportNamedDeclaration.from({
        declaration: null,
        specifiers,
        source,
        // @ts-expect-error TODO(wrong) get ast-types and recast to handle this
        exportKind: isTypeOnly ? 'type' : 'value',
      });
    } else {
      ensureUnreachable(exportClause);
      return errorStatement(
        node,
        // @ts-expect-error yes, the types say this is unreachable
        `unexpected export clause: ${formatSyntaxKind(exportClause.kind)}`,
      );
    }
  }

  function convertExportAssignment(node: ts.ExportAssignment): K.StatementKind {
    if (node.isExportEquals) {
      return unimplementedStatement(node, '"export ="');
    }

    if (!ts.isIdentifier(node.expression)) {
      // TODO(runtime): These don't appear in .d.ts files, but do in TS.
      return unimplementedStatement(
        node,
        `"export default" with non-identifier`,
      );
    }

    return b.exportDefaultDeclaration(convertIdentifier(node.expression));
  }

  function convertVariableStatement(
    node: ts.VariableStatement,
  ): K.StatementKind {
    const flags =
      node.declarationList.flags & (ts.NodeFlags.Const | ts.NodeFlags.Let);
    const kind =
      flags === ts.NodeFlags.Const
        ? 'var' // TODO(runtime): For .js.flow files, we always declare `var`, not `const`
        : flags === ts.NodeFlags.Let
        ? 'let'
        : 'var';

    return b.variableDeclaration(
      kind,
      map(node.declarationList.declarations, convertVariableDeclaration),
    );

    function convertVariableDeclaration(declaration: ts.VariableDeclaration) {
      const name = declaration.name /* TODO */ as ts.Identifier;
      const type = declaration.type
        ? convertType(declaration.type)
        : convertInitializerToType(declaration.initializer);
      return b.variableDeclarator(convertIdentifier(name, type));
    }

    function convertInitializerToType(init: ts.Expression | void) {
      // TS generates lines like `export declare const Foo = 'Foo'` in .d.ts
      // files; when reading those, it infers the specific type from the
      // literal.  Flow requires the type to be explicit if it's exported.
      if (!init) {
        return b.anyTypeAnnotation();
      } else if (ts.isStringLiteral(init)) {
        return b.stringLiteralTypeAnnotation(init.text, init.text);
      } else if (ts.isNumericLiteral(init)) {
        return b.numberLiteralTypeAnnotation(Number(init.text), init.text);
      } else if (ts.isEnumMember(init)) {
        return unimplementedType(
          init,
          `const type inferred from literal enum reference`,
        );
      } else {
        // TODO(runtime): Without `declare` TS does more inference than
        //   this.  Do we need to do any of it to help Flow?
        //
        // With `declare`, if you say `declare const x = []`,
        // TS gives an error reading:
        //   > A 'const' initializer in an ambient context must be a string
        //   > or numeric literal or literal enum reference.
        //
        // I.e., the cases we covered above.  So in a `.d.ts` file,
        // this case shouldn't arise.
        return errorType(
          init,
          `const type inferred from ${formatSyntaxKind(init.kind)}`,
        );
      }
    }
  }

  function convertTypeAliasDeclaration(
    node: ts.TypeAliasDeclaration,
  ): K.StatementKind {
    const symbol = checker.getSymbolAtLocation(node.name);
    const mapped = symbol && mapper.getSymbol(symbol);
    let name = node.name.text;
    if (mapped) {
      switch (mapped.kind) {
        case 'RenameType':
          name = mapped.name;
          break;
        case 'FixedName':
        case 'SubstituteType':
        case 'TypeReferenceMacro':
          break;
        default:
          assertUnreachable(mapped, (m) => `TypeRewrite kind: ${m.kind}`);
      }
    }

    return b.typeAlias(
      b.identifier(name),
      convertTypeParameterDeclaration(node.typeParameters),
      convertType(node.type),
    );
  }

  function convertFunctionDeclaration(node: ts.FunctionDeclaration) {
    if (!node.name) {
      if (
        hasModifier(node, ts.SyntaxKind.ExportKeyword) &&
        hasModifier(node, ts.SyntaxKind.DefaultKeyword)
      ) {
        // TS accepts this, and then puts it in `.d.ts` files.  But there
        // doesn't seem to be a Flow equivalent if you say `declare`; and if
        // you don't, then implementations are required.  Probably the
        // solution is we should generate a fresh name.
        return unimplementedStatement(
          node,
          '`export default function` with no name',
        );
      }

      // I believe this is not valid TS.
      return errorStatement(node, 'expected name on FunctionDeclaration');
    }

    return b.declareFunction(
      convertIdentifier(node.name, convertFunctionType(node)),
    );
  }

  function convertClassLikeDeclaration(
    node: ts.ClassDeclaration | ts.InterfaceDeclaration,
  ) {
    if (!node.name) {
      if (
        hasModifier(node, ts.SyntaxKind.ExportKeyword) &&
        hasModifier(node, ts.SyntaxKind.DefaultKeyword)
      ) {
        // TS accepts this, and then puts it in `.d.ts` files.  But there
        // doesn't seem to be a Flow equivalent if you say `declare`; and if
        // you don't, then implementations are required.  Probably the
        // solution is we should generate a fresh name.
        return unimplementedStatement(
          node,
          '`export default class` with no name',
        );
      }

      // I believe this is not valid TS.
      return errorStatement(node, 'anonymous class not in `export default`');
    }

    const typeParameters = convertTypeParameterDeclaration(node.typeParameters);

    const extends_: n.InterfaceExtends[] = [];
    const implements_: n.ClassImplements[] = [];
    for (const heritageClause of node.heritageClauses ?? []) {
      for (const base of heritageClause.types) {
        if (heritageClause.token === ts.SyntaxKind.ImplementsKeyword) {
          // Class implements; a pure type reference.
          const result = convertTypeHeritage(base, `class 'implements'`);
          if (Array.isArray(result)) return result[0];
          // @ts-expect-error TODO(ast-types) fix `id` type to accept qualified name
          implements_.push(b.classImplements.from(result));
          //
        } else if (ts.isInterfaceDeclaration(node)) {
          // Interface extends; a pure type reference.
          const result = convertTypeHeritage(base, `interface 'extends'`);
          if (Array.isArray(result)) return result[0];
          extends_.push(b.interfaceExtends.from(result));
          //
        } else {
          // Class extends; a hybrid type/value reference.
          // TODO this logic is wrong, as if for a pure type reference.
          const result = convertTypeHeritage(base, `class 'extends'`);
          if (Array.isArray(result)) return result[0];
          extends_.push(b.interfaceExtends.from(result));
        }
      }
    }

    const members = convertMembers(node);
    if (!Array.isArray(members)) {
      return statementOfError(node, members);
    }
    const [properties, indexers, callProperties] = members;
    const body = b.objectTypeAnnotation(properties, indexers, callProperties);

    if (ts.isInterfaceDeclaration(node)) {
      return b.declareInterface.from({
        id: convertIdentifier(node.name),
        typeParameters,
        extends: extends_,
        body,
      });
    } else {
      return b.declareClass.from({
        id: convertIdentifier(node.name),
        typeParameters,
        extends: extends_,
        implements: implements_,
        body,
      });
    }

    function convertTypeHeritage(
      base: ts.ExpressionWithTypeArguments,
      description: string,
    ):
      | [K.StatementKind]
      | {
          id: K.IdentifierKind | n.QualifiedTypeIdentifier;
          typeParameters: n.TypeParameterInstantiation | null;
        } {
      const { expression, typeArguments } = base;
      const name = ensureEntityNameExpression(expression, description);
      if (Array.isArray(name)) return name;

      const result = convertTypeReferenceLike(name, typeArguments);
      if (result.kind !== 'success') {
        return [statementOfError(node, result)];
      }
      return result.result;
    }

    function ensureEntityNameExpression(
      expression: ts.LeftHandSideExpression,
      desc: string,
    ): ts.EntityNameExpression | [K.StatementKind] {
      if (
        !ts.isIdentifier(expression) &&
        !ts.isPropertyAccessExpression(expression)
      ) {
        return [
          errorStatement(
            node,
            `unexpected ${desc} base kind: ${formatSyntaxKind(
              expression.kind,
            )}`,
          ),
        ];
      }
      if (!isEntityNameOrEntityNameExpression(expression)) {
        return [errorStatement(node, `${desc} not an entity name`)];
      }
      return expression;
    }
  }

  function convertType(node: ts.TypeNode): K.FlowTypeKind {
    switch (node.kind) {
      case ts.SyntaxKind.UnknownKeyword:
        return b.mixedTypeAnnotation();
      case ts.SyntaxKind.AnyKeyword:
        return b.anyTypeAnnotation();
      case ts.SyntaxKind.NeverKeyword:
        return b.emptyTypeAnnotation();

      case ts.SyntaxKind.UndefinedKeyword:
      case ts.SyntaxKind.VoidKeyword:
        return b.voidTypeAnnotation();
      case ts.SyntaxKind.BooleanKeyword:
        return b.booleanTypeAnnotation();
      case ts.SyntaxKind.NumberKeyword:
        return b.numberTypeAnnotation();
      case ts.SyntaxKind.StringKeyword:
        return b.stringTypeAnnotation();
      case ts.SyntaxKind.SymbolKeyword:
        return b.symbolTypeAnnotation();
      case ts.SyntaxKind.ObjectKeyword:
        return b.objectTypeAnnotation.from({ properties: [], inexact: true });

      case ts.SyntaxKind.ThisType:
        return b.thisTypeAnnotation();

      case ts.SyntaxKind.ParenthesizedType:
        // TODO: Am I missing something?
        return convertType((node as ts.ParenthesizedTypeNode).type);

      case ts.SyntaxKind.LiteralType:
        return convertLiteralType(node as ts.LiteralTypeNode);

      case ts.SyntaxKind.TypeQuery: {
        const { exprName } = node as ts.TypeQueryNode;
        return b.typeofTypeAnnotation(
          b.genericTypeAnnotation(convertEntityNameAsType(exprName), null),
        );
      }

      case ts.SyntaxKind.TypeOperator:
        return convertTypeOperator(node as ts.TypeOperatorNode);

      case ts.SyntaxKind.ImportType:
        return convertImportType(node as ts.ImportTypeNode);

      case ts.SyntaxKind.TypeReference:
        return convertTypeReference(node as ts.TypeReferenceNode);

      case ts.SyntaxKind.UnionType:
        return convertUnionType(node as ts.UnionTypeNode);

      case ts.SyntaxKind.IntersectionType: {
        const { types } = node as ts.IntersectionTypeNode;
        return b.intersectionTypeAnnotation(types.map(convertType));
      }

      case ts.SyntaxKind.IndexedAccessType:
        // TODO?: Look for `Foo[keyof Foo]` (including `Foo` an expression,
        //   in particular `typeof bar`), and make that `$Values<Foo>`.
        //   Seems a Flow bug that that's any different; but it works better
        //   on npm:react-native-gesture-handler/State, cutting 75 errors
        //   from its rdeps.
        return buildElementType(
          convertType((node as ts.IndexedAccessTypeNode).objectType),
          convertType((node as ts.IndexedAccessTypeNode).indexType),
        );

      case ts.SyntaxKind.ArrayType:
        return b.arrayTypeAnnotation(
          convertType((node as ts.ArrayTypeNode).elementType),
        );

      case ts.SyntaxKind.TupleType:
        return convertTupleType(node as ts.TupleTypeNode);

      case ts.SyntaxKind.FunctionType:
        return convertFunctionType(node as ts.FunctionTypeNode);

      case ts.SyntaxKind.TypeLiteral:
        return convertTypeLiteral(node as ts.TypeLiteralNode);

      case ts.SyntaxKind.TypePredicate:
      case ts.SyntaxKind.ConstructorType:
      case ts.SyntaxKind.ConditionalType:
      case ts.SyntaxKind.InferType:
      case ts.SyntaxKind.MappedType:
      case ts.SyntaxKind.TemplateLiteralType:
      case ts.SyntaxKind.TemplateLiteralTypeSpan:
        return unimplementedType(node, formatSyntaxKind(node.kind));

      case ts.SyntaxKind.NamedTupleMember:
      case ts.SyntaxKind.OptionalType:
      case ts.SyntaxKind.RestType:
        // Not actually types -- pieces of types.  We handle these below,
        // as part of handling the types they appear in.
        return errorType(
          node,
          `unexpected type kind: ${formatSyntaxKind(node.kind)}`,
        );

      default:
        return errorType(
          node,
          `unexpected type kind: ${formatSyntaxKind(node.kind)}`,
        );
    }
  }

  function convertLiteralType(node: ts.LiteralTypeNode): K.FlowTypeKind {
    switch (node.literal.kind) {
      case ts.SyntaxKind.NullKeyword:
        return b.nullTypeAnnotation();
      case ts.SyntaxKind.FalseKeyword:
        return b.booleanLiteralTypeAnnotation(false, 'false');
      case ts.SyntaxKind.TrueKeyword:
        return b.booleanLiteralTypeAnnotation(true, 'true');

      case ts.SyntaxKind.PrefixUnaryExpression: {
        const literal = node.literal as ts.PrefixUnaryExpression;
        if (literal.operator !== ts.SyntaxKind.MinusToken) {
          return errorType(
            node,
            `LiteralTypeNode with PrefixUnaryExpression operator ${formatSyntaxKind(
              literal.operator,
            )}; expected MinusToken`,
          );
        }
        if (!ts.isNumericLiteral(literal.operand)) {
          return errorType(
            node,
            `LiteralTypeNode with unary-minus of ${formatSyntaxKind(
              literal.operand.kind,
            )}; expected NumericLiteral`,
          );
        }
        const { text } = literal.operand;
        // TODO: is more conversion needed on these number literals?
        return b.numberLiteralTypeAnnotation(-Number(text), text);
      }

      case ts.SyntaxKind.NumericLiteral: {
        const { text } = node.literal;
        // TODO: is more conversion needed on these number literals?
        return b.numberLiteralTypeAnnotation(Number(text), text);
      }

      case ts.SyntaxKind.StringLiteral: {
        const { text } = node.literal;
        // TODO: is more conversion needed on these string literals?
        return b.stringLiteralTypeAnnotation(text, text);
      }

      case ts.SyntaxKind.BigIntLiteral: // TODO is this possible?
      default:
        return errorType(
          node,
          `unexpected literal-type kind: ${formatSyntaxKind(
            node.literal.kind,
          )}`,
        );
    }
  }

  function convertTypeOperator(node: ts.TypeOperatorNode): K.FlowTypeKind {
    const { operator, type } = node;
    switch (operator) {
      case ts.SyntaxKind.KeyOfKeyword:
        return b.genericTypeAnnotation(
          b.identifier('$Keys'),
          b.typeParameterInstantiation([convertType(type)]),
        );

      case ts.SyntaxKind.ReadonlyKeyword:
        return warningType(
          convertType(type),
          node,
          `unimplemented: 'readonly' as type operator`,
        );

      case ts.SyntaxKind.UniqueKeyword:
        return unimplementedType(
          node,
          `type operator: ${formatSyntaxKind(operator)}`,
        );

      default:
        return errorType(
          node,
          `unexpected type operator: ${formatSyntaxKind(operator)}`,
        );
    }
  }

  function convertImportType(node: ts.ImportTypeNode): K.FlowTypeKind {
    if (
      !ts.isLiteralTypeNode(node.argument) ||
      !ts.isStringLiteral(node.argument.literal)
    ) {
      // TS (as of 4.6.2) gives an error if the argument to `import(…)`
      // isn't a string literal, saying "String literal expected."
      // So this case should be impossible.
      return errorType(
        node,
        `invalid argument to import(…): not a string literal`,
      );
    }
    const moduleSpecifier = node.argument.literal.text;

    if (node.isTypeOf) {
      // The reference is under a `typeof`, referring to the type of some
      // value: either the module as a whole, or some dotted name inside it.
      //
      // (`typeof import(…).foo` doesn't get parsed as a ts.TypeQueryNode
      // like `typeof` ordinarily does, but rather as just this `isTypeOf`
      // flag on the ts.ImportTypeNode.)

      const localName = ensureImportTypeofWhole(moduleSpecifier);

      // We've imported the module itself under `typeof`.  Here's a
      // reference to that:
      const typeofModule = b.genericTypeAnnotation(
        b.identifier(localName),
        null, // already an actual value type, not generic -- doesn't take type parameters
      );

      // Now apply the qualifier.  Get a list of the dot-separated names:
      const names = [];
      let qualifier = node.qualifier;
      if (qualifier) {
        while (ts.isQualifiedName(qualifier)) {
          names.push(qualifier.right.text);
          qualifier = qualifier.left;
        }
        names.push(qualifier.text);
      }

      // … and apply them one by one, starting from the module's own type.
      let result: K.FlowTypeKind = typeofModule;
      let name;
      while ((name = names.pop()) !== undefined) {
        result = buildElementType(
          result,
          b.stringLiteralTypeAnnotation(name, name),
        );
      }

      return result;
    } else {
      // The reference is to some named type directly.
      //
      // We can't get this through an `import typeof`; more generally,
      // there doesn't seem to be a way to get this in Flow (a) by a
      // single import of the module (b) without causing a runtime import
      // (which could have side effects.)  So, import the individual item.

      const { qualifier } = node;
      if (!qualifier) {
        // If you write something like `import("foo")` in type position,
        // with no indirections after the module, TS gives an error.
        return errorType(node, `Whole module from 'import(…)' used as a type`);
      }

      if (!ts.isIdentifier(qualifier)) {
        // On the other hand if you write more than one indirection, like
        // `import("foo").bar.baz` -- without `typeof` -- then the
        // intermediate ones must be TS namespaces.  After all, the only
        // things a type can be nested in are a module (aka a TS "external
        // module", corresponding to a real JS module) or a TS namespace
        // (aka a TS "internal module").
        //
        // Namespaced types don't have a direct equivalent in Flow, and we
        // don't yet support them.
        return unimplementedType(node, `namespaced type via import(…)`);
      }

      // TODO Send the type through the mapper.

      const localName = ensureImportTypeIndividual(
        moduleSpecifier,
        qualifier.text,
      );
      return b.genericTypeAnnotation(
        b.identifier(localName),
        convertTypeArguments(
          checker.getSymbolAtLocation(qualifier),
          node.typeArguments,
        ),
      );
    }

    function ensureImportTypeofWhole(moduleSpecifier: string) {
      const localName = escapeNamesAsIdentifierWithPrefix(
        '$tsflower_import_typeof',
        moduleSpecifier,
      );
      if (!importTypeImports.has(localName)) {
        importTypeImports.add(localName);
        preambleStatements.push(
          b.importDeclaration.from({
            importKind: 'typeof',
            source: b.stringLiteral(moduleSpecifier),
            // TODO or should it be a default import?
            specifiers: [b.importNamespaceSpecifier(b.identifier(localName))],
          }),
        );
      }
      return localName;
    }

    function ensureImportTypeIndividual(moduleSpecifier: string, name: string) {
      const localName = escapeNamesAsIdentifierWithPrefix(
        '$tsflower_import_type',
        moduleSpecifier,
        name,
      );
      if (!importTypeImports.has(localName)) {
        importTypeImports.add(localName);
        // TODO It'd be kind of nice to collect these in one statement per
        //   imported module.
        preambleStatements.push(
          b.importDeclaration.from({
            importKind: 'type',
            source: b.stringLiteral(moduleSpecifier),
            specifiers: [
              b.importSpecifier(b.identifier(name), b.identifier(localName)),
            ],
          }),
        );
      }
      return localName;
    }
  }

  function convertTypeReference(node: ts.TypeReferenceNode): K.FlowTypeKind {
    const result = convertTypeReferenceLike(node.typeName, node.typeArguments);
    if (result.kind !== 'success') {
      return typeOfError(node, result);
    }
    return b.genericTypeAnnotation.from(result.result);
  }

  /** (This calls `mapper.getSymbol`.  Each call site should therefore have
   * a corresponding case in the visitor in `createMapper`.) */
  function convertTypeReferenceLike(
    typeName: ts.EntityNameOrEntityNameExpression,
    typeArguments: ts.NodeArray<ts.TypeNode> | void,
  ): ErrorOr<{
    id: K.IdentifierKind | n.QualifiedTypeIdentifier;
    typeParameters: n.TypeParameterInstantiation | null;
  }> {
    const mapped = mapper.getTypeName(typeName);
    if (mapped) {
      switch (mapped.kind) {
        case 'SubstituteType':
          ensureEmittedSubstitute(mapped);
        // fallthrough

        case 'FixedName':
        case 'RenameType':
          return mkSuccess({
            id: b.identifier(mapped.name),
            typeParameters: convertTypeArguments(
              checker.getSymbolAtLocation(typeName),
              typeArguments,
            ),
          });

        case 'TypeReferenceMacro':
          return mapped.convert(converter, typeName, typeArguments);

        default:
          assertUnreachable(mapped, (m) => `TypeRewrite kind: ${m.kind}`);
      }
    }
    return mkSuccess({
      id: convertEntityNameAsType(typeName),
      typeParameters: convertTypeArguments(
        checker.getSymbolAtLocation(typeName),
        typeArguments,
      ),
    });

    function ensureEmittedSubstitute(rewrite: SubstituteType) {
      if (substituteTypes.has(rewrite.name)) return;
      substituteTypes.add(rewrite.name);
      forEach(rewrite.dependencies, ensureEmittedSubstitute);
      preambleStatements.push(...rewrite.substitute());
    }
  }

  function convertEntityNameAsType(
    node: ts.EntityNameOrEntityNameExpression,
  ): K.IdentifierKind | K.QualifiedTypeIdentifierKind {
    if (ts.isIdentifier(node)) return convertIdentifier(node);
    if (ts.isQualifiedName(node)) {
      return b.qualifiedTypeIdentifier(
        convertEntityNameAsType(node.left),
        convertIdentifier(node.right),
      );
    }
    return b.qualifiedTypeIdentifier(
      convertEntityNameAsType(node.expression),
      convertIdentifier(node.name),
    );
  }

  function convertUnionType(node: ts.UnionTypeNode): K.FlowTypeKind {
    return b.unionTypeAnnotation(node.types.map(convertType));
  }

  function convertTupleType(node: ts.TupleTypeNode): K.FlowTypeKind {
    let warningDescription;
    const elements: K.FlowTypeKind[] = [];
    for (const element of node.elements) {
      if (
        ts.isOptionalTypeNode(element) ||
        (ts.isNamedTupleMember(element) && element.questionToken)
      ) {
        // Flow has no equivalent.  It could be emulated by a union of tuple
        // types, though imperfectly because Flow limits itself on unions.
        warningDescription = `unimplemented: optional tuple member`;
        break;
      }
      if (
        ts.isRestTypeNode(element) ||
        (ts.isNamedTupleMember(element) && element.dotDotDotToken)
      ) {
        // Flow has no equivalent.  Could be approximated from below by a
        // union out to some finite length, or from above by an array type.
        warningDescription = `unimplemented: rest tuple member`;
        break;
      }
      elements.push(
        convertType(ts.isNamedTupleMember(element) ? element.type : element),
      );
    }

    const result = b.tupleTypeAnnotation(elements);

    return warningDescription
      ? warningType(result, node, warningDescription)
      : result;
  }

  function convertFunctionType(
    node:
      | ts.FunctionTypeNode
      | ts.FunctionDeclaration
      | ts.ConstructorDeclaration
      | ts.MethodSignature
      | ts.MethodDeclaration,
  ): K.FlowTypeKind {
    const typeParams = convertTypeParameterDeclaration(node.typeParameters);

    const params: n.FunctionTypeParam[] = [];
    let restParam = null;
    for (let i = 0; i < node.parameters.length; i++) {
      const param = node.parameters[i];

      // TS requires a name for each parameter in a function type; you can
      // get out of it by using a binding-pattern instead.  Flow doesn't
      // require a name -- you can just write the type -- so if you don't
      // want a name, just omit it.
      //
      // We give up a bit of documentation value by discarding the pattern,
      // but that's all.
      const name = !ts.isIdentifier(param.name)
        ? null
        : convertIdentifier(param.name);

      if (param.dotDotDotToken) {
        // This is a rest parameter, so (if valid TS) must be the last one.
        restParam = b.functionTypeParam(
          name,
          // TS function parameter types must have names, but can lack types.
          // When missing, for a rest param the type is implicitly `any[]`.
          param.type
            ? convertType(param.type)
            : b.arrayTypeAnnotation(b.anyTypeAnnotation()),
          false,
        );
        break;
      }

      params.push(
        b.functionTypeParam(
          name,
          // TS function parameter types must have names, but can lack types.
          // When missing, the type is implicitly `any`.
          param.type ? convertType(param.type) : b.anyTypeAnnotation(),
          !!param.questionToken,
        ),
      );
    }

    // TS function types always have explicit return types, but
    // FunctionDeclaration may not.  Implicitly that means `any`.
    const resultType = node.type
      ? convertType(node.type)
      : b.anyTypeAnnotation();

    return b.functionTypeAnnotation(params, resultType, restParam, typeParams);
  }

  function convertTypeLiteral(node: ts.TypeLiteralNode): K.FlowTypeKind {
    const members = convertMembers(node);
    if (!Array.isArray(members)) {
      return typeOfError(node, members);
    }
    const [properties, indexers, callProperties] = members;

    const exact = true; // TODO

    return b.objectTypeAnnotation.from({
      properties,
      indexers,
      callProperties,
      exact,
      inexact: !exact,
    });
  }

  function convertMembers(
    node: ts.ClassDeclaration | ts.InterfaceDeclaration | ts.TypeLiteralNode,
  ):
    | ErrorDescription
    | [
        (n.ObjectTypeProperty | n.ObjectTypeSpreadProperty)[],
        n.ObjectTypeIndexer[] | undefined,
        n.ObjectTypeCallProperty[] | undefined,
      ] {
    const properties: (n.ObjectTypeProperty | n.ObjectTypeSpreadProperty)[] =
      [];
    const indexers: n.ObjectTypeIndexer[] = [];
    const callProperties: n.ObjectTypeCallProperty[] | undefined = []; // TODO

    for (const member of node.members) {
      convertMember(member);
    }

    return [properties, indexers, callProperties];

    function convertMember(member: ts.ClassElement | ts.TypeElement) {
      switch (member.kind) {
        case ts.SyntaxKind.Constructor:
          convertConstructor(member as ts.ConstructorDeclaration);
          break;

        case ts.SyntaxKind.PropertySignature:
        case ts.SyntaxKind.PropertyDeclaration:
          convertProperty(
            member as ts.PropertySignature | ts.PropertyDeclaration,
          );
          break;

        case ts.SyntaxKind.IndexSignature:
          convertIndexer(member as ts.IndexSignatureDeclaration);
          break;

        case ts.SyntaxKind.GetAccessor:
          convertGetAccessor(member as ts.GetAccessorDeclaration);
          break;

        case ts.SyntaxKind.SetAccessor:
          convertSetAccessor(member as ts.SetAccessorDeclaration);
          break;

        case ts.SyntaxKind.MethodSignature:
        case ts.SyntaxKind.MethodDeclaration:
          convertMethod(member as ts.MethodSignature | ts.MethodDeclaration);
          break;

        case ts.SyntaxKind.CallSignature:
        case ts.SyntaxKind.ConstructSignature:
        case ts.SyntaxKind.SemicolonClassElement:
        case ts.SyntaxKind.ClassStaticBlockDeclaration:
          properties.push(
            propertyOfError(
              member,
              mkUnimplemented(
                `ClassElement|TypeElement kind: ${formatSyntaxKind(
                  member.kind,
                )}`,
              ),
            ),
          );
          break;

        default:
          properties.push(
            propertyOfError(
              member,
              mkError(
                `unexpected ClassElement|TypeElement kind: ${formatSyntaxKind(
                  member.kind,
                )}`,
              ),
            ),
          );
      }
    }

    function convertProperty(
      member: ts.PropertySignature | ts.PropertyDeclaration,
    ) {
      {
        const { name, questionToken, type } = member;
        const keyResult = convertName(name);
        if (!keyResult) return;
        if (keyResult.kind !== 'success') {
          properties.push(propertyOfError(member, keyResult));
          return;
        }
        const key = keyResult.result;

        const variance = hasModifier(member, ts.SyntaxKind.ReadonlyKeyword)
          ? 'plus'
          : null;

        properties.push(
          b.objectTypeProperty.from({
            variance,
            key,
            optional: !!questionToken,
            value: type ? convertType(type) : b.anyTypeAnnotation(),
          }),
        );
      }
    }

    function convertIndexer(member: ts.IndexSignatureDeclaration) {
      const { parameters, type: valueType } = member;

      if (parameters.length !== 1) {
        properties.push(
          propertyOfError(
            member,
            mkError(`TS index signature must have exactly 1 parameter`),
          ),
        );
        return;
      }
      const parameter = parameters[0];
      const { name, type: keyType } = parameter;

      indexers.push(
        b.objectTypeIndexer(
          // The "parameter" in a TS index signature is always an
          // identifier; if you try to write a binding pattern, it doesn't
          // even parse.
          convertIdentifier(name as ts.Identifier),
          // The "parameter type" in a TS index signature is mandatory;
          // without it, the syntax doesn't even parse as an index
          // signature, but rather as a property with a computed name.
          convertType(keyType!),
          convertType(valueType),
        ),
      );
    }

    function convertGetAccessor(member: ts.GetAccessorDeclaration) {
      const { name, type } = member;

      const keyResult = convertName(name);
      if (!keyResult) return;
      if (keyResult.kind !== 'success') {
        properties.push(propertyOfError(member, keyResult));
        return;
      }
      const key = keyResult.result;

      // A missing result type is implicitly `any` in TS, but forbidden in Flow.
      const returnType = !type ? b.anyTypeAnnotation() : convertType(type);

      const value = b.functionTypeAnnotation.from({
        returnType,
        params: [], // A TS getter takes no parameters
        rest: null, // … so in particular no rest-parameter
        typeParameters: null, // A TS accessor has no type parameters
      });

      properties.push(
        b.objectTypeProperty.from({
          key,
          kind: 'get',
          value,
          optional: false,
        }),
      );
    }

    function convertSetAccessor(member: ts.SetAccessorDeclaration) {
      const { name, parameters } = member;

      const keyResult = convertName(name);
      if (!keyResult) return;
      if (keyResult.kind !== 'success') {
        properties.push(propertyOfError(member, keyResult));
        return;
      }
      const key = keyResult.result;

      // TODO: Refactor convertFunctionType so as to reuse most of it here.

      if (parameters.length !== 1) {
        properties.push(
          propertyOfError(
            member,
            mkError(`TS setter must take exactly 1 parameter`),
          ),
        );
        return;
      }
      const parameter = parameters[0];

      // Take the name or leave it, much the same as for a normal function;
      // see `convertFunctionType`.
      const paramName = !ts.isIdentifier(parameter.name)
        ? null
        : convertIdentifier(parameter.name);

      const param = b.functionTypeParam(
        paramName,
        parameter.type ? convertType(parameter.type) : b.anyTypeAnnotation(),
        false, // TS setter cannot be optional
      );

      const value = b.functionTypeAnnotation.from({
        returnType: b.voidTypeAnnotation(),
        params: [param],
        rest: null, // A TS setter cannot take a rest-parameter
        typeParameters: null, // A TS accessor has no type parameters
      });

      properties.push(
        b.objectTypeProperty.from({
          key,
          kind: 'set',
          value,
          optional: false,
        }),
      );
    }

    function convertConstructor(member: ts.ConstructorDeclaration) {
      properties.push(
        b.objectTypeProperty.from({
          key: b.identifier('constructor'),
          // TODO: return type should be void, not any
          value: convertFunctionType(member),
          optional: false,
          method: true,
        }),
      );
    }

    function convertMethod(member: ts.MethodSignature | ts.MethodDeclaration) {
      const { name, questionToken } = member;
      const keyResult = convertName(name);
      if (!keyResult) return;
      if (keyResult.kind !== 'success') {
        properties.push(propertyOfError(member, keyResult));
        return;
      }
      const key = keyResult.result;

      properties.push(
        b.objectTypeProperty.from({
          key,
          value: convertFunctionType(member),
          optional: !!questionToken,
          method: true,
        }),
      );
    }

    function convertName(
      name: ts.PropertyName,
    ): null | ErrorOr<K.IdentifierKind | K.LiteralKind> {
      switch (name.kind) {
        case ts.SyntaxKind.Identifier:
          return mkSuccess(convertIdentifier(name));

        case ts.SyntaxKind.PrivateIdentifier:
          // A private property in `declare class` is useless, because it
          // can't be referred to by anything using the declaration.
          // (Private properties can only be referred to within the class
          // definition.)  TS allows them, but Flow doesn't; just drop it
          // from the output.
          // TODO(runtime): Handle private properties.
          return null;

        case ts.SyntaxKind.StringLiteral:
          if (!name.text) {
            // The property has an empty name.
            switch (node.kind) {
              case ts.SyntaxKind.InterfaceDeclaration:
              case ts.SyntaxKind.ClassDeclaration:
                // Flow disallows an empty-named property in some contexts.
                // (Flow bug?  Seems like JS classes allow these just fine.)
                return mkUnimplemented(
                  `empty-named property on class or interface`,
                );

              case ts.SyntaxKind.TypeLiteral:
                // But it allows it in others.  Go ahead as if nonempty.
                break;

              default:
                assertUnreachable(
                  node,
                  (n) => `node in convertMembers: ${formatSyntaxKind(n.kind)}`,
                );
            }
          }

          return mkSuccess(b.stringLiteral(name.text));

        case ts.SyntaxKind.NumericLiteral:
          // Flow doesn't accept a number for a property key in an object
          // type.  But at runtime, such a key really means its
          // stringification anyway; so emit that in the type.  (It's
          // possible this still leaves glitches on trying to use the type.)
          //
          // Note that `ts.NumericLiteral#text` isn't the original text from
          // the source code; it's the result of parsing and unparsing (the
          // latter implemented as `value + ""`, in `createNumericLiteral`
          // in `src/compiler/factory/nodeFactory.ts`.)  So that's exactly
          // what we want here.
          return mkSuccess(b.stringLiteral(name.text));

        case ts.SyntaxKind.ComputedPropertyName:
          return mkUnimplemented(
            `PropertyName kind ${formatSyntaxKind(name.kind)}`,
          );

        default:
          ensureUnreachable(name);
          return mkError(
            // @ts-expect-error yes, the types say this is unreachable
            `PropertyName kind ${formatSyntaxKind(name.kind)}`,
          );
      }
    }

    function propertyOfError(
      node: ts.Node,
      desc: ErrorDescription,
    ): n.ObjectTypeProperty {
      return b.objectTypeProperty.from({
        key: b.identifier(`$tsflower$property$${properties.length}`),
        value: typeOfError(node, desc),
        optional: false,
      });
    }
  }

  function convertTypeParameterDeclaration(
    params: void | ts.NodeArray<ts.TypeParameterDeclaration>,
  ): null | n.TypeParameterDeclaration {
    return !params
      ? null
      : b.typeParameterDeclaration(
          params.map((param) =>
            b.typeParameter(
              param.name.text,
              null,
              // TODO consider calling `getEffectiveConstraintOfTypeParameter`,
              //   per param.constraint jsdoc
              !param.constraint
                ? null
                : b.typeAnnotation(convertType(param.constraint)),
              !param.default ? null : convertType(param.default),
            ),
          ),
        );
  }

  function convertTypeArguments(
    typeNameSymbol: void | ts.Symbol,
    typeArguments: void | ts.NodeArray<ts.TypeNode>,
  ): null | n.TypeParameterInstantiation {
    if (typeArguments) {
      return b.typeParameterInstantiation(typeArguments.map(convertType));
    }

    // If in TS there was no list of type arguments, that can be either
    // because the type takes no parameters, or because it has defaults for
    // all parameters and this reference is using the defaults.  In the
    // latter case, while TS requires it to be spelled with no list, Flow
    // requires it to be spelled with an empty list.
    // @ts-expect-error TODO(tsutil) express "does decl have type parameters"
    if (some(typeNameSymbol?.declarations, (decl) => !!decl.typeParameters)) {
      return b.typeParameterInstantiation([]);
    }

    return null;
  }

  function convertIdentifier(
    node: ts.Identifier,
    type?: K.FlowTypeKind,
  ): K.IdentifierKind {
    // TODO(rename): audit this function's callers
    return !type
      ? b.identifier(node.text)
      : b.identifier.from({
          name: node.text,
          typeAnnotation: b.typeAnnotation(type),
        });
  }

  function buildElementType(
    objectType: K.FlowTypeKind,
    indexType: K.FlowTypeKind,
  ): K.FlowTypeKind {
    return b.genericTypeAnnotation(
      // TODO(flow-155): Switch to Flow indexed-access-type syntax.
      b.identifier('$ElementType'),
      b.typeParameterInstantiation([objectType, indexType]),
    );
  }

  function statementOfError(
    node: ts.Statement,
    desc: ErrorDescription,
  ): K.StatementKind {
    return desc.kind === 'error'
      ? errorStatement(node, desc.description)
      : unimplementedStatement(node, desc.description);
  }

  function warningStatement(
    outNode: K.StatementKind,
    node: ts.Statement,
    description: string,
  ): K.StatementKind {
    const msg = ` tsflower-warning: ${description} `;
    return {
      ...outNode,
      // TODO(error): Get the quoted original before the output, to be next
      //   to the warning description
      comments: [b.commentBlock(msg, true, false), quotedStatement(node)],
    };
  }

  function unimplementedStatement(
    node: ts.Statement,
    description: string,
  ): K.StatementKind {
    const msg = ` tsflower-unimplemented: ${description} `;
    return b.emptyStatement.from({
      comments: [b.commentBlock(msg, true, false), quotedStatement(node)],
    });
  }

  function errorStatement(
    node: ts.Statement,
    description: string,
  ): K.StatementKind {
    const msg = ` tsflower-error: ${description} `;
    return b.emptyStatement.from({
      comments: [b.commentBlock(msg, true, false), quotedStatement(node)],
    });
  }

  function typeOfError(node: ts.Node, desc: ErrorDescription): K.FlowTypeKind {
    return desc.kind === 'error'
      ? errorType(node, desc.description)
      : unimplementedType(node, desc.description);
  }

  function warningType(
    outNode: K.FlowTypeKind,
    node: ts.TypeNode,
    description: string,
  ): K.FlowTypeKind {
    const msg = ` tsflower-warning: ${description} `;
    return {
      ...outNode,
      // TODO(error): Get the quoted original before the output, to be next
      //   to the warning description
      comments: [b.commentBlock(msg, true, false), quotedInlineNode(node)],
    };
  }

  function unimplementedType(
    node: ts.Node,
    description: string,
  ): K.FlowTypeKind {
    const msg = ` tsflower-unimplemented: ${description} `;
    return b.genericTypeAnnotation.from({
      id: b.identifier('$FlowFixMe'),
      typeParameters: null,
      comments: [quotedInlineNode(node), b.commentBlock(msg, false, true)],
    });
  }

  function errorType(node: ts.Node, description: string): K.FlowTypeKind {
    const msg = ` tsflower-error: ${description} `;
    return b.genericTypeAnnotation.from({
      id: b.identifier('$FlowFixMe'),
      typeParameters: null,
      comments: [quotedInlineNode(node), b.commentBlock(msg, false, true)],
    });
  }

  function quotedStatement(node: ts.Statement): K.CommentKind {
    const text = sourceFile.text.slice(node.pos, node.end);
    // Defang any nested close-comment markers `*/`.
    return b.commentBlock(` ${text.replaceAll('*/', '* /')} `, false, true);
  }

  function quotedInlineNode(node: ts.Node): K.CommentKind {
    const text = sourceFile.text.slice(node.pos, node.end);
    // Defang any nested close-comment markers `*/`.
    return b.commentBlock(` ${text.replaceAll('*/', '* /')} `, false, true);
  }

  function crudeError(node: ts.Node, description: string): never {
    // TODO(error): Better than node.pos would be a whitespace-trimmed version.
    //   (As is, when something is the first thing on its line `pos` can be
    //   the end of the last non-whitespace line.)
    const start = ts.getLineAndCharacterOfPosition(sourceFile, node.pos);
    const end = ts.getLineAndCharacterOfPosition(sourceFile, node.end);
    const loc =
      start.line === end.line
        ? `${1 + start.line}:${start.character}-${end.character}`
        : `${1 + start.line}-${1 + end.line}`;
    throw new Error(
      `Internal error on ${formatSyntaxKind(node.kind)} at ${
        sourceFile.fileName
      }:${loc}: ${description}`,
    );
  }
}
